// ==UserScript==
// @name         Mrgaton youtube downloader
// @namespace    http://tampermonkey.net/
// @version      2025-10-27
// @description  Download using crun and my awesome program
// @author       Mrgaton
// @match        https://www.youtube.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=youtube.com
// @downloadURL  https://raw.githubusercontent.com/Mrgaton/YoutuveDownloader/master/script.user.js
// @updateURL 	 https://raw.githubusercontent.com/Mrgaton/YoutuveDownloader/master/script.user.js

// @grant        GM.xmlHttpRequest
// @grant        GM.getValue
// @grant        GM.setValue
// ==/UserScript==


(() => { const e = "https://df.gato.ovh/d/ajIIkGQAARMGp8msT9dw-rc6fC7hcHwC$NDRxeSGlkpezq5I/YoutuveDownloader.exe", t = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" focusable="false" aria-hidden="true" style="pointer-events: none; display: inherit; width: 100%; height: 100%;"><path d="M12 2a1 1 0 00-1 1v11.586l-4.293-4.293a1 1 0 10-1.414 1.414L12 18.414l6.707-6.707a1 1 0 10-1.414-1.414L13 14.586V3a1 1 0 00-1-1Zm7 18H5a1 1 0 000 2h14a1 1 0 000-2Z"></path></svg>'; async function n(e) { await new Promise((t => setTimeout(t, e))) } function o(e) { const t = typeof e; "string" === t || "boolean" === t ? console.debug("[MrgatonYTDownloader]: " + e) : (console.debug("[MrgatonYTDownloader]:"), console.debug(e)) } function r(e) { e.innerHTML && (e.hooked || (o("Adding event to button "), e.addEventListener("click", (() => a(e))), e.hooked = !0)) } function a(n) { o("YouTube button clicked "), o(n.innerHTML.includes(t)), function (t) { if (!I.installed()) return void alert("Error crun no esta instalado por favor instalalo primero"); o(t), o("Vamos a descargar: " + window.location.href), o(I), confirm("Are you want to download this video?\n\nPress OK or Cancel.") && I.run(e, '"video=' + window.location.href + '"') }(n) } (async () => { o("Waiting for buttons to load"); let e = 200; for (; !document.getElementById("menu");)o("Waiting buttons to load"), await n(e), e <= 2e3 && (e += 200); o("Initializing buttons events"), async function () { o("Installing script"), r(document.querySelector("#flexible-item-buttons > ytd-download-button-renderer > ytd-button-renderer > yt-button-shape > button")), function (e) { for (const t in e) { r(e[t]) } }(document.getElementsByClassName("style-scope ytd-menu-popup-renderer")) }(), o("Initializing mutation observer"), new MutationObserver(i).observe(document, { childList: !0, subtree: !0 }) })(); try { window.trustedTypes && window.trustedTypes.createPolicy && window.trustedTypes.createPolicy("default", { createHTML: e => e, createScriptURL: e => e, createScript: e => e }) } catch (e) { console.error(e) } function i(e, t) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { if (o(e.nodeName), "REMOVEDELEMENTFORDEVELOMPHMENT" === e.nodeName) e.remove(); else if ("YTD-MENU-SERVICE-ITEM-DOWNLOAD-RENDERER" === e.nodeName) { document.getElementsByClassName("ytd-menu-service-item-download-renderer")[0].addEventListener("click", (() => a(button))) } })) })); const n = document.getElementById("flexible-item-buttons"); n && n.remove() } let s = ["#top-level-buttons-computed", "#flexible-item-buttons", "ytd-menu-renderer"]; function u() { const e = s.map((e => document.querySelector(e))).find(Boolean); if (!e) return o("No suitable container found for download button."), null; const n = e.querySelector('ytd-download-button-renderer, button[aria-label*="Descargar"], button[data-injected-download-button]'); if (n) return o("Download button already exists, skipping insertion."), n; const r = function () { const e = document.createElement("button"); return e.setAttribute("type", "button"), e.setAttribute("aria-label", "Descargar"), e.setAttribute("title", "Descargar"), e.dataset.injectedDownloadButton = "true", e.className = "yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading", e.innerHTML = `\n      <div aria-hidden="true" class="yt-spec-button-shape-next__icon">\n        <svg width="24" height="24" viewBox="0 0 24 24" focusable="false" aria-hidden="true">${t}</svg>\n      </div>\n      <div class="yt-spec-button-shape-next__button-text-content">Descargar</div>\n    `, e.addEventListener("click", (t => { e.dispatchEvent(new CustomEvent("youtube-download-click", { bubbles: !0 })), t.preventDefault() })), e }(); if (!r) return o("createDownloadButton returned null or undefined."), null; const a = document.createElement("yt-button-view-model"); a.className = "ytd-menu-renderer", a.setAttribute("class", "ytd-menu-renderer"), "string" == typeof r ? (o("createDownloadButton returned string, inserting as HTML."), a.insertAdjacentHTML("beforeend", r)) : r instanceof Node ? (o("createDownloadButton returned Node, appending."), a.appendChild(r)) : console.warn("insertIfMissing: createDownloadButton returned unsupported type", r); const i = e.querySelector("#flexible-item-buttons"); return o("Inserting download button into container. Flexible section found: " + Boolean(i)), i ? i.appendChild(a) : e.appendChild(a), a } let c = new MutationObserver((e => { u() })); c.observe(document.documentElement, { childList: !0, subtree: !0 }); let l = u(); if (window.youtubeDownloadInjector = { getButton: () => document.querySelector("[data-injected-download-button]"), insertNow: () => u(), onCreate: null, disconnect: () => c.disconnect() }, window.youtubeDownloadInjector.onCreate = e => { r(e) }, l && "function" == typeof window.youtubeDownloadInjector.onCreate) try { window.youtubeDownloadInjector.onCreate(l) } catch (e) { console.error(e) } const d = new MutationObserver((e => { const t = document.querySelector("[data-injected-download-button]"); if (t) { if ("function" == typeof window.youtubeDownloadInjector.onCreate) try { window.youtubeDownloadInjector.onCreate(t) } catch (e) { console.error(e) } d.disconnect() } })); let p; d.observe(document.documentElement, { childList: !0, subtree: !0 }), console.info("youtubeDownloadInjector instalado. Use window.youtubeDownloadInjector.getButton() para obtener el botón o establezca window.youtubeDownloadInjector.onCreate = (btn) => { ... } para enganchar creación."); let h = document.body, m = document.createElement("span"); m.innerHTML = Array(100).join("wi"), m.style.cssText = ["position:absolute", "width:auto", "font-size:128px", "left:-99999px"].join(" !important;"); const f = function (e) { return m.style.fontFamily = e, h.appendChild(m), p = m.clientWidth, h.removeChild(m), p }, w = f("monospace"), y = f("serif"), b = f("sans-serif"); window.isFontAvailable = function (e) { return w !== f(e + ",monospace") || b !== f(e + ",sans-serif") || y !== f(e + ",serif") }; const g = ["1.7.1.0"]; let v = "CRNTOKEN"; let C = this.localStorage.getItem(v); (!C || C.length < 32) && (C = function (e) { let t = ""; const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; for (let o = 0; o < e; o++)t += n[62 * Math.random() | 0]; return t }(32), this.localStorage.setItem(v, C)); const I = { installPage: function () { window.location.replace("https://github.com/Mrgaton/CRUNInstaller/releases/latest") }, installed: function () { return !(!navigator.brave || !navigator.brave.isBrave()) || window.isFontAvailable("crun-rfont") }, runElement: function (e) { let t = e.getAttribute("type"), n = []; switch (n.push(t), t) { case "run": n.push(e.getAttribute("fileName") ?? "cmd.exe"), n.push("args=" + e.getAttribute("arguments") ?? ""); break; case "cmd": n.push(e.getAttribute("command") ?? "cmd.exe"), n.push("autoclose=" + e.getAttribute("autoclose") ?? "true"); break; case "zip": n.push(e.getAttribute("fileName") ?? "example.exe"), n.push("zip=" + e.getAttribute("zip")), n.push("autoclose=" + e.getAttribute("autoclose") ?? "true"); break; case "ps1": case "eps1": n.push(e.getAttribute("command") ?? "echo hola"), n.push("autoclose=" + e.getAttribute("autoclose") ?? "true") }n.push("shell=" + e.getAttribute("shell") ?? "true"), n.push("hide=" + e.getAttribute("hide") ?? "false"), n.push("uac=" + e.getAttribute("uac") ?? "false"), console.log(...n), this.runCore(...n) }, runCore: function (...e) { e.push('tarjetVersion="' + g.join(",") + '"'), e.push("cname=" + window.location.hostname), e.push("ctoken=" + C); let t = document.createElement("iframe"); t.style.display = "none", document.body.appendChild(t), t.src = "crun://" + function (...e) { return (Array.isArray(e[0]) ? e[0] : e).map(encodeURIComponent).join("/") }(e), console.debug("CRUN: " + t.src) }, run: function (e, t, n = !1, o = !1, r = !1, ...a) { if (r && !o) throw new Error("Shell must be enabled when elevating uac privileges."); let i = []; i.push("run"), i.push(e), i.push("args=" + (t || "")), i.push("uac=" + E(r)), i.push("shell=" + E(o)), i.push("hide=" + E(n)); for (let e = 0; e < a.length; e++) { let t = "boolean" == typeof a[e]; i.push(t ? E(a[e]) : a[e]) } this.runCore(...i) }, runPs1: function (e, t = !1, n = !1, ...o) { let r = []; r.push("ps1"), r.push(e), r.push("hide=" + E(n)), r.push("autoClose=" + E(t)); for (let e = 0; e < o.length; e++) { let t = "boolean" == typeof o[e]; r.push(t ? E(o[e]) : o[e]) } this.runCore(...r) }, runCmd: function (e, t = !1, n = !1, ...o) { let r = []; r.push("cmd"), r.push(e), r.push("hide=" + E(n)), r.push("autoClose=" + E(t)); for (let e = 0; e < o.length; e++) { let t = "boolean" == typeof o[e]; r.push(t ? E(o[e]) : o[e]) } this.runCore(...r) } }; function E(e) { return e ? "1" : "0" } function R(e) { return "1" === e || "true" === e || "yes" === e || "y" === e || "ok" === e } const x = "http://127.0.0.1:51213", N = async (e, t = {}) => { await A(), t.headers || (t.headers = {}), t.headers.authorization = C; const n = await fetch(`${x}/${e}`, t), o = await n.text(); if (n.status > 300) throw new Error(o); return o }; let U; const A = async (e = 600, t = !0) => { try { const t = await fetch(x + "/health", { headers: { authorization: C }, signal: AbortSignal.timeout(e), method: "GET", priority: "high" }); return console.log("[CrunServer] Sending heartbeat: " + await t.status), t.status } catch (e) { return console.error(e), t && (await new Promise((e => setTimeout(e, 100))), L.checkAndStart()), 0 } }; document.addEventListener("click", (function (e) { "BUTTON" !== e.target.tagName && "BUTTON" !== e.type.toUpperCase() || function (e) { const t = e.getAttribute("crun"); if (!t) return; const n = t.indexOf(";"); if (-1 === n) return; const o = t.slice(0, n), r = t.slice(n + 1), a = o.trim(), i = (u = r, u.split(",").map((e => { const t = e.trim(), n = t.toLowerCase(); return "" === n ? "" : "true" === n || "false" !== n && (isNaN(t) ? encodeURIComponent(t) : Number(t)) }))), s = function (e, t) { const n = t.split("."); let o = e; for (const e of n) { if (!o || "object" != typeof o) return; { const t = Object.keys(o).find((t => t.toLowerCase() === e.toLowerCase())); if (!t) return; o = o[t] } } return o }(L, a); var u; "function" == typeof s ? s(...i) : console.warn(`Method '${a}' not found on CrunServer.`) }(e.target) })); let D = 0; const L = { checkAndStart: async function () { let e = !1; 200 == await A(600, !1) && (e = !0); const t = Date.now(); return !e && t - D >= 1e4 && (I.runCore("server"), D = t, setTimeout(A, 1e3)), U || (U = setInterval(A, 7e3)), e }, stop: function () { I.runCore("stop"), clearInterval(U), U = null }, runAsync: async function (e, t = "", n = !1, o = !0, r = !1) { return await L.run(e, t, n, o, r) }, run: async function (e, t = "", n = !1, o = !0, r = !1, a = !1) { if (r && !o) throw new Error("Shell must be enabled when elevating uac privileges."); return await N("run?path=" + encodeURIComponent((i = e, i.replace(/\//g, "\\").replace(/\\\\/g, "\\"))) + "&args=" + encodeURIComponent(t) + "&hide=" + E(n) + "&uac=" + E(r) + "&shell=" + E(null == o || o) + "&async=" + E(a)); var i }, runPowershell: async function (e, t = !0, n = !1, o = !1, r = !0) { return await L.run("%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", "-NoLogo -NonInteractive -NoProfile -ExecutionPolicy Bypass" + (t ? null : " -NoExit") + ' -Command "& "' + e + '""', n, r, o) }, files: { write: async function (e, t) { e || (e = "."); return R((await N("write?path=" + encodeURIComponent(e), { method: "POST", body: t })).trim().toLocaleLowerCase()) }, exist: async function (e) { e || (e = "."); return R((await N("exist?path=" + encodeURIComponent(e))).trim().toLocaleLowerCase()) }, list: async function (e, t = "") { e || (e = "."); const n = await N("list?path=" + encodeURIComponent(e) + "&pattern=" + t); let o = []; return n.split("\n").forEach((e => { o.push(e) })), o }, read: async function (e) { const t = await N("read?path=" + encodeURIComponent(e) + "&base64=true"); return atob(t) }, move: async function (e, t) { const n = await N("move?path=" + encodeURIComponent(e) + "&new=" + encodeURIComponent(t)); return atob(n) }, download: async function (e, t) { return await N("download?url=" + encodeURIComponent(e) + "&path=" + encodeURIComponent(t)) }, delete: async function (e) { return await N("delete?path=" + encodeURIComponent(e)) }, attributes: async function (e) { return await N("attributes?path=" + encodeURIComponent(e)) } }, directory: { delete: async function (e, t = !0) { return await N("delete?path=" + encodeURIComponent(e) + "&recursive=" + t) }, list: async function (e, t) { return await L.files.list(e) }, exist: async function (e) { return await L.files.exist(e.trim("/") + "/") }, getCurrentDirectory: async function () { return await N("gcd") }, setCurrentDirectory: async function (e) { return "" === await N("scd?path=" + encodeURIComponent(e)) } }, services: { start: async function (e, ...t) { return await N("service/start?path=" + e + "&args=" + t.map((function (e) { return encodeURIComponent(e) })).join("|")) }, stop: async function (e) { return await N("service/stop?path=" + e) }, restart: async function (e, ...t) { return await N("service/restart?path=" + e + "&args=" + t.map((function (e) { return encodeURIComponent(e) })).join("|")) }, info: async function (e) { const t = (await N("service/info?path=" + e)).split("|"); return { name: t[0], type: t[1], start: t[2], status: t[3] } }, list: async function () { let e = []; return (await N("service/list")).split("\n").forEach((t => { const n = t.split("|"); e.push({ name: n[0], type: n[1], start: n[2], status: n[3] }) })), e } }, registry: { get: async function (e, t) { return await N("registry/get?path=" + encodeURIComponent(e) + "&key=" + t) }, set: async function (e, t, n, o) { return await N("registry/set?path=" + e + "&key=" + t + "&value=" + encodeURIComponent(n) + "&kind=" + o) }, delete: async function (e, t) { return await N("registry/delete?path=" + encodeURIComponent(e) + "&key=" + t) }, list: async function (e) { return await N("registry/list?path=" + encodeURIComponent(e)) } }, managementSearch: async function (e) { const t = await N("management/query?path=" + encodeURIComponent(e)); let n = {}; return t.split("\n").forEach((e => { let t = e.split("|"); n[t[0]] = Number(t[1]) })), n }, dllInvoke: async function (e, t, n, o) { return await N("dllinvoke?dll=" + encodeURIComponent(e) + "&method=" + encodeURIComponent(t) + "&params=" + encodeURIComponent(o) + "&returnType=" + n ?? "void") }, processList: async function () { let e = {}; return (await N("plist")).split("\n").forEach((t => { let n = t.split("|"); e[n[0]] = Number(n[1]) })), e }, getEnv: async function () { let e = (await N("env")).split("\n"), t = {}; for (let n of e) { if (!n.trim() || n.trim().startsWith("#")) continue; let e = n.indexOf("="); if (-1 === e) continue; let o = n.slice(0, e).trim(), r = n.slice(e + 1).trim(); t[o] = r } return t }, killProcess: async function (...e) { return Number(await N("pkill?name=" + e.join("|"))) }, killProcessById: async function (e) { return Number(await N("pkill?pid=" + e)) }, extractZip: async function (e, t) { return await N("unzip?url=" + encodeURIComponent(e) + "&path=" + encodeURIComponent(t)) } } })();